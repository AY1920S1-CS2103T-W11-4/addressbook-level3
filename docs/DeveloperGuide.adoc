= CaloFit - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-W11-4/main

By: `Team CaloFit (AY1920S1-CS2103T-W11-4)`      Since: `Sep 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]

=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `DishListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `CommandParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a meal).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the DishDatabase data and MealLog data.
* exposes an unmodifiable `ObservableList<Meal>` and `ObservableList<Dish>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `ModelManager`, which `Dish` can reference. This would allow `ModelManager` to only require one `Tag` object per unique `Tag`, instead of each `Dish` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the DishDatabase data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.calofit.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Add feature
==== Implementation
===== Addition though flags (e.g add n/Chicken c/200 t/dry)

The `add` feature is implemented through the `AddCommand` class that extends the abstract `Command` class.
It interacts with other objects through the `Model` interface to manipulate the meal log and dish database to add meals.

The addition of meals is done through `Model#addMeal()` which would add the meal from the meal log list.

The `add` feature uses the Model to check if the dish is already in the database.
If the dish is already in the database, the meal will be added to the meal log only through the `Model#addMeal()` method.
If the dish the user wants to add is not in the database,
then the dish will be added to both the meal log and the dish database through the `Model#addMeal()` and
`Model#addDish()` methods respectively.

There are a few cases to take note:

* If the dish name is in the dish database:
** The user inserts the calorie information that is the same as the one in the dish database
*** The dish will be added to the meal log only.

** The user inserts the calorie information different from the calorie in the dish database
*** This will create a new dish all together as there are differences in the calorie
*** The new dish will be added to both the meal log as well as the dish database

** The user does not insert the calorie information
*** The program will look through the dish database and get the calorie information from that dish.

* If the dish name is not in the dish database
** The user inserts the calorie information
*** A new dish is created with that name and calorie information
*** The dish will then be added to both the dish database as well as the meal log.

** The user does not insert the calorie information
*** The program sets the calorie information to 700 by default.
*** The dish will then be added to both the dish database as well as the meal log

The following sequence diagram shows how the `add` operation works when calorie information is included:

image::AddSequenceDiagram.png[]

To detect whether the calorie tag is used in the user input, we use an UNKNOWN_CALORIE in the Calorie class.
This will trigger either search for the dish in the dish database or create a new dish and input it into the dish database.

The input by the user and the dish in the dish database is considered equal only if both the name and the calorie information are the same.

Addition of tags are supported. However, they are not crucial to the implementation of the add
function as tags are not considered when deciding equality of dishes.

===== Addition though indexes in suggested/find meal list (e.g add 1 2 3)
The `add` feature also supports the addition of meals through indexes in the suggested meal list.
This is done to improve the user experience as they do not have to always enter the long commands.

This feature is also implemented through the `AddCommand` class that extends the abstract `Command` class.

The `add` command in this case takes in a list of numbers pass to it through the `AddCommandParser`. The checking of valid
indexes is done by the `AddCommandParser`. Once the list is passed to the `AddCommand`, it calls `Model#getFilteredDishlist()`
which returns the filtered dish list. The add command will then loop through
the list of indexes and get the respective dishes from the filtered dish list.

We cannot add the meal immediately to the meal log as the filtered dish list would change when the calorie count changes. Hence the
meals are first added to separate a `toBeAddedMealList` and once all the indexes are added to that list,
`MealLog#addListOfMeals(toBeAddedMealList)` is called to add all the meals in to the meal log at once.

==== Design Consideration
===== Aspect: What is considered the same meal
* **Alternative 1 (Current choice):** Compare name and calorie only
** Pros: More precise compared to just comparing names.
** Cons: Complications when adding meals.

* **Alternative 2:** Compare name only
** Pros: Easy comparison. Reduces complications when adding meals.
** Cons: High collision.

* **Explanation of choice:** As a calorie counter, the calories is an important
part of the meal. Hence we need to consider it when comparing meals. Certain meals
with the same name may not have the same amount of calories. Hence we decided to go
with alternative 1.

=== Delete feature
==== Implementation
The `delete` feature is implemented through the `DeleteCommand` class that extends the abstract `Command` class.
It interacts with other objects through the `Model` interface to manipulate the meal log and remove meals.

The `delete` command allows for removal of multiple dishes with a single command.
The `delete` command takes in a `listOfIndex` passed to it by the `DeleteCommandParser`. The checking of valid integers
is done by the `DeleteCommandParser`. Once the listOfIndex is passed to the `DeleteCommand`, it sorts the list from largest index
to smallest index using the `Collections.sort(listOfIndex, Comparator.reverseOrder())`. The `DeleteCommand` then loops through
the sorted list and checks if the index is within the size of the meal log. If the index is valid, `DeleteCommand` will
remove the respective meal from the meal log.

The removal of meals is done through the `Model#removeMeal(meal)` which would remove the meal from the meal log list.

The following sequence diagram shows how the `delete` operation works when index 1 is deleted:

image::DeleteSequenceDiagram.png[]

Below is the activity diagram that summarises the scenario when "delete 1" is called by the user.

image::DeleteActivityDiagram.png[]

==== Design Consideration
===== Aspect: How is the meal removed

* **Alternative 1 (Current Choice):** Removed after the listOfIndex is sorted.
** Pros: Prevent the reordering of the meal log causing the larger indexes to correspond to a different meal or
out of bounds. (e.g delete 1 2 for a meal log with 2 meals. If we delete 1 first, the meal log will change to having 1 meal.
The meal previously at index 2 is now at index 1. When doing delete 2, the meal at index 2 is now out of bounds as the meal log
only has 1 meal.)
** Cons: The command may take some time when handling large amounts of input. This is due to the sorting required.

* **Alternative 2:** Loop through the indexes in the `DeleteCommandParser` and create a new `DeleteCommand` for every index.
** Pros: Simple morphing of previous delete method.
** Cons: Have to change other parts of the model breaking abstraction.

* ** Explanation of Choice:** The command is for the deletion of meals for that day. A person on average consumes 3 - 4 meals a day.
Hence on average, the most meals to be deleted is 4. Thus the sorting time would not be too significant. Also,



=== Budget Bar display

The budget bar display provides a graphic overview of meals consumed on the current day,
comparing against the total calorie budget set by the user.

==== Implementation

The budget bar feature is implemented via the `BudgetBar` class.
It is a JavaFx UI component, which wraps around `MealLog` and `CalorieBudget`.
`MealLog` provides an observable list of meals eaten today,
while `CalorieBudget` provides the currently set user budget.

Using helper code from `ObservableUtil` and `ObservableListUtil`,
we compute several derived properties:

* Total calories consumed
* Percentage of budget consumed

From there, we again construct further observable/reactive values representing:

* Bar info text color
** Transitions from green to red, when more budget is consumed
* Bar info text
** If budget has been set, shows `<Total Consumed> / <Budget>`.
** If budget has not been set, only shows `<Total Consumed>`.
* Meal segments
** Each meal is displayed as a proportionally-sized segment in the whole bar.
* Position of warning/danger markers

The following activity diagram shows the reactive update dependencies.

image::BudgetMealUpdate.png[]

==== Design Consideration

===== Aspect: Base UI component to display meal segments.

* **Alternative 1 (current choice):**
Use ControlsFx's `SegmentedBar` class to handle display of bar segments.
** Pros:
*** No need to reimplement JavaFx `setLayout` logic
*** Better performance than `GridPane`
** Cons:
*** Dependency on external library
*** Have to create a separate `BufferSegment` class to represent gap.
* **Alternative 2:**
Use JavaFx's `GridPane` to lay out bar segments, and `ColumnConstraints` to appropriately set column widths.
** Pros:
*** No external library (other than JavaFx) needed
** Cons:
*** Poor performance to due `Observable` machinery and `GridPane` layout
* Explanation of choice:
Simpler implementation and better performance outweighs the cost of using an external library.


// tag::assistance[]
=== Assistance features

// tag::find[]
==== Find feature

The find feature display the result of the searched dish on the right pane to the user.

===== Implementation

The find mechanism is toggled when the user type in the "find" command. Through a `FindCommand` that extends from the abstract `Command` class. It interacts with the object that implements `Model` interface by updating the observable list with a predicate that contains what the user is searching for.

Given below is a Class Diagram that shows how the FindCommand interacts with other components of CaloFit.

image::FindClassDiagram.png[]

Given below is an example usage scenario and how the find mechanism behaves at each step.

Step 1. The user starts up CaloFit for the first time. The `DishDatabase` will be loaded with the initial data by calling `MainApp#loadDishDatabase`.

[NOTE]
If the DishDatabase is empty, nothing will be display.

Step 2. The user enters "find soup" in the Command Line Input to invoke the `FindCommand` command which will run `FindCommand#execute()`. `Model#setDishFilterPredicate()` will be executed to update the observable list with the given predicate.

Step 3. The number of dishes found will be return, while printing the updated dish list on CaloFit right pane.


===== Design Considerations

===== Aspect: How find executes

* **Alternative 1 (current choice):** Update dish list with the search result
** Pros: Neater code, easier to maintain and uses lesser memory.
** Cons: Unable to get history of find list.
* **Alternative 2:** Create a new list for every `FindCommand`.
** Pros: Easier to understand and customise if require data for method.
** Cons: Unnecessary memory wastage for list created and not used.
* **Explanation of Choice:** Since we only need to show what the current user finds, there are no usage for the past find result.

===== Aspect: Data structure to support the find command

* **Alternative 1 (current choice):** Stores the value in a dish list.
** Pros: Commonly used, thus easier to understand and easier to deal with. It can also be easily updated.
** Cons: Would constantly require `Model` with a responsibility that is not relevant to it's current.
* **Alternative 2:** Wrap the values in a `Find` object
** Pros: Neater and easier to maintain, since all find-related values are stored in the `Find` object.
** Cons: Additional class to maintain, harder for newcomers to understand code with too many classes.
// end::find[]

// tag::suggest[]
==== Suggest feature
The suggest feature displays the suggested automatically to the user accordingly to the remaining calorie budget.

===== Implementation

The suggest mechanism is toggled when the application starts up. It will always display the suggested meals for the user in the right pane. The feature can be can be toggled back by typing the "suggest" command. Through a `SuggestCommand` that extends from the abstract `Command` class. It interacts with the object that implements the `Model` interface by updating the observable list with dishes that are within the calories budget. The calories budget is obtained from `Model#getRemainingCalories()`.

Additionally, it implements the following operation:

* `Model#getRemainingCalories` -- gets the current allowed calories budget.

This operation is exposed in the `Model` interface as `Model#getRemainingCalories()`.

Given below is an example usage scenario and how the suggest mechanism behaves at each step.

Step 1. The user starts up CaloFit for the first time. The `DishDatabase` will be loaded with the initial data by calling `MainApp#loadDishDatabase`.

[NOTE]
If the DishDatabase is empty, or the daily calorie budget have exceeded the set amount, or there are no dishes that is within the amount, nothing will be display.

Step 2. The user enters "suggest" in the Command Line Input to invoke the `SuggestCommand` command which will run `SuggestCommand#execute()`. `Model#getRemainingCalories()` will be executed to get the remaining calories, which will provide `#Model#updateFilteredDishList` with the calories budget to update the list accordingly.

Step 3. The success message will be return, while printing the updated dish list on CaloFit right pane.

The following sequence diagram shows how the suggest operation works:

image::SuggestCommand.png[]

===== Design Considerations

===== Aspect: How suggest executes

* **Alternative 1 (current choice):** Update dish list with calorie budget
** Pros: Neater code, easier to maintain and uses lesser memory.
** Cons: Unable to get history of suggest list.
* **Alternative 2:** Create a new list for every `SuggestCommand`.
** Pros: Easier to understand and customise if require data for method.
** Cons: Unnecessary memory wastage for list created and not used.
* **Explanation of Choice:** Since we only need to show the user the current meal suggest, there are no usage for the past suggest result.

===== Aspect: Data structure to support the suggest command

* **Alternative 1 (current choice):** Stores the value in a dish list.
** Pros: Commonly used, thus easier to understand and easier to deal with. It can also be easily updated.
** Cons: Would constantly require `Model` with a responsibility that is not relevant to it's current.
* **Alternative 2:** Wrap the values in a `Suggest` object
** Pros: Neater and easier to maintain, since all suggest-related values are stored in the `Suggest` object.
** Cons: Additional class to maintain, harder for newcomers to understand code with too many classes.
// end::suggest[]

// tag::notification[]
==== Notification feature
The notification feature prompts the user with new window pane if a meal have been missed.

===== Implementation

The notification feature is automatically activated when the application starts up. On start up, it is implemented through a  `NotificationHelper` that gets information from `Model#getMealLog().getTodayMeals()` method to check if there are any meal consumed and if a meal has been consumed. The `NotificationHelper` class would the do a check on the timestamp of the latest meals by using various methods in the `Notification` class, more details explain below. If a meal have been missed, a notification will be prompted to the user to consume their meal, this prompt will constantly pop up every 10 minutes until a meal have been consumed. If a meal have been consumed within the period then the user can continue using the application without any prompt.

Additionally, it implements the following operation:

* A "timer" object that is in the `UIManager` class will ensure that the notifications are executed on a 10 minutes interval.

* `Notification#eatenBreakfast` -- returns a boolean value to indicate have the user eaten their breakfast.

* `Notification#eatenLunch` -- returns a boolean value to indicate have the user eaten their lucnh.

* `Notification#eatenDinner` -- returns a boolean value to indicate have the user eaten their dinner.

Given below is an example usage scenario and how the notification mechanism behaves at each step.

Step 1. The user starts up CaloFit for the first time. The `DishDatabase` will be loaded with the initial data by calling `MainApp#loadDishDatabase` with an empty MealLog.

[NOTE]
The application will immediately check once when the application is launched, then followed by every 10 minutes interval.

Step 2. The application will then execute `NotificationHelper` once to check if any meal have been missed. If there is none then no notification will be prompted. If a meal is missed it will prompt to the user, and notify them every 10 minutes.

Step 3. After 10 minutes, `UIManager` will then execute `NotificationHelper` and check if the user have keyed in any meals. This process will carry on for every 10 mintues till the user key in their meal.

The following sequence diagram shows how the suggest operation works:

image::NotificationActivityDiagram.png[]

===== Design Considerations

===== Aspect: How notification executes

* **Alternative 1 (current choice):** Refocus the notification Window.
** Pros: Ensure that lesser memory is used, so that buffer overflow is not possible. Furthermore user would not be annoying by multiple tabs.
** Cons: Higher chance of notification not showing up due to a single error.
* **Alternative 2:** Create a new Window for each notification
** Pros: Less prone to mistake as previous notification will still stay till user clear it.
** Cons: Require much more memory as a new window is created, if the user was away for a period of time and the application was left opened, user would be required to clear quite a number of tabs.
* **Explanation of Choice:** Since this feature provide the user as an assistance, we should not bring in more hassle and inconvenience to the user. Thus even with a higher risk of notification not showing up due to error. After 10 more minutes the notification will be prompted.
// end::notification[]

// tag::assistance[]

// tag::report[]
=== Report feature
==== Implementation

The Report feature is implemented through a `ReportCommand` that extends from the abstract `Command` class. +
It returns a `CommandResult` object that has the boolean "isReport" set to True when `ReportCommand#execute(Model)` is called. +
The `MainWindow` Ui component will check the `CommandResult` for the "isReport" boolean and create a new `ReportWindow` through the `MainWindow#handleReport()` method. +
The `ReportWindow` object takes in a `Statistics` object that is created by calling `Logic#getStatistics()` which subsequently calls `Model#getStatistics()`. The `Model` then returns the `Statistics` object that is created based on the `CalorieBudget` and `MealLog` in the `Model`. +
Additionally, the following operations are implemented in `Statistics`:

* `Statistics#generateStatistics(ObservableList<Meal>, CalorieBudget)` -- gets the statistics of the current object. Maximum, Minimum and Average calorie intake per day of the current month are calculated internally in this method.

[NOTE]
While the above method takes in an `ObservableList<Meal>` instead of a `MealLog`, the list is generated from the `MealLog` and passed as the argument to avoid unnecessary interaction between the `MealLog` and `Statistics` classes. +
Therefore, even though `MealLog` is not taken in as a parameter, `Statistics` still depeneds on `MealLog` to get the data for generating the report.

* `Statistics#getCalorieExceedCount(CalorieBudget, ObservableList<Meal>)` -- gets the number of days where calorie intake exceeded the calorie budget for that day.
* `Statistics#getMostConsumedDishes(ObservableList<Meal>)` -- gets the list of dishes which are consumed the most in the current month.
* `Statistics#getFoodChartSeries(ObservableList<Meal>)` -- gets the series containing the dishes eaten this month and their respective quantities.
* `Statistics#getCalorieChartSeries(ObservableList<Meal)` -- gets the series that representing the amount of calories taken by the user over the past month.

Given below is a Class Diagram that shows how the ReportCommand interacts with other components of CaloFit.

image::ReportClassDiagram.png[]

Given below is an example usage scenario and how the Report feature behaves at each step.

Step 1. The user starts up CaloFit for the first time. The `ModelManager` will contain a `MealLog` that has an empty list.

[NOTE]
If the user enters "report" in the Command Line Input with a `MealLog` that has no `Meal` entered this month, a `CommandException` will be thrown since there are no `Meal` to gather statistics pertaining to this month.

Step 2. The user has added a `Meal` into the `MealLog` through the `add` feature.

Step 3. The user enters "report" in the Command Line Input to generate the report of CaloFit. The `ReportCommand` created will return a `CommandResult` object with "isReport" set to True. When the `MainWindow` checks this boolean, it calls `MainWindow#handleReport()` that creates the `ReportWindow`.

The following activity diagram summarises the above usage scenario.

image::ReportCommandActivityDiagram.png[]

The following sequence diagram shows how the "report" command works.

image::ReportCommand.png[]

[NOTE]
The parameters of the constructor of `CommandResult` in the above diagram are as follows, from left to right: +
String message -- the message to be displayed to the user in the GUI. +
boolean showHelp: indicates if the `HelpWindow` should be generated. +
boolean showReport: indicates if the `ReportWindow` should be generated. +
boolean isExit: indicates if the application should exit along with any other windows that are being shown. +
Hence, only showReport is set to true to indicate that a `ReportWindow` should be created, while the rest of the booleans are set to false.

The following sequence diagram shows how the `ReportWindow` is generated.

image::ReportWindow.png[]

==== Design Considerations

===== Aspect: When the `Statistics` object is created.

* **Alternative 1 (current choice):** Only when a "report" command is entered.
** Pros: Less processes carried out for each type of command.
** Cons: At any point in using CaloFit, the statistics are not updated since the object is only created when the "report" command is entered.
* **Alternative 2:** Every command creates a new updated `Statistics` object.
** Pros: Logging of statistics can be accurate, and statistics are always updated.
** Cons: Unnecessary as user does not need to see the statistics other than through a "report" command and results in every command having to do more work and interact with the `Model` more, possibly creating more bugs.
* **Explanation of Choice:** Since the user only needs to see the updated statistics when a "report" command is executed, we only need to generate a new `Statistics` object with the updated values for that command, hence **Alternative 1** is chosen to avoid adding unnecessary complexity to each command.

===== Aspect: Data structure to store the statistics in CaloFit.

* **Alternative 1 (current choice):** Wrap the values in a `Statistics` object.
** Pros: Neater code and easier to understand, since all statistic-related values are stored in the `Statistics` object and are not implemented in the `Model`.
** Cons: Additional class to maintain and test for dependencies.
* **Alternative 2:** Store the values as a list in the `Model`.
** Pros: The statistics can be updated easily through the `Model` itself by updating the elements in the list. Accessing the statistics to display is easier as well.
** Cons: Burdens the `Model` with a responsibility that is largely irrelevant to its current ones, which is to keep track of the Objects that make up the CaloFit model.
* **Explanation of Choice:** To try and enforce Single Responsibility Principle as much as possible and avoid adding irrelavant functionality to `Model`.
// end::report[]






=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope
=== Target User Profile
* Health-conscious people watching their diet
* Prefer desktop applications over mobile apps
* Comfortable enough to work with text command-based interfaces

=== Value Proposition
The app is able to help the user keep track of their calorie consumption. This way, they can ensure that they keep to their own diet plans.

[appendix]
== User Stories

[width="59%",cols="4*",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|&#11088;&#11088;&#11088;
|new user
|see usage instructions
|refer to instructions when I forget how to use the App.

|&#11088;&#11088;&#11088;
|user
|create a new meal entry
|keep track of what I ate today.

|&#11088;&#11088;&#11088;
|user
|see how many calories I have left in today's budget
|know what I can eat later, and stay in budget.

|&#11088;&#11088;&#11088;
|user
|be alerted if I missed a meal
|be reminded to stick to my meal plans.

|&#11088;&#11088;&#11088;
|user
|change my daily calorie budget
|better reflect my new lifestyle requirements.

|&#11088;&#11088;
|user
|modify my previous meal entries
|fix missing or inaccurate information.

|&#11088;&#11088;
|user
|delete my previous meal entries
|undo mistakenly added meal entries.

|&#11088;&#11088;
|user
|generate a summary of meals over the past month
|review my overall progress in keeping to my meal plan.

|&#11088;&#11088;
|user
|view meal suggestions that fit in my remaining budget.
|figure out what I can eat while keeping to my plan.

|&#11088;
|user
|create a new meal entry based of a meal I commonly eat
|keep track of a meal I eat often.

|=======================================================================
_{More to be added}_

[appendix]
== Use Cases

// [discrete]
=== Use Case: Add meal entry

*MSS*

1.	User enters meal information.
2.	System adds entry into database.
3.	System shows updated calorie budget for the day.
Use case ends.

*Extensions*

* 1a.	The given meal entry has insufficient information (calories, meal name, etc.)
+
[none]
** 1a1.	CaloFit shows an error message.
+
Use case restarts at step 1.

_{More to be added}_

[appendix]
== Non-functional Requirements
.	Should work on any mainstream OS as long as it has Java 11 or above installed.
.	Should be able to hold up to 1000 meal entries without a noticeable sluggishness in performance for typical usage.
.	A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary
[[mainstream-os]] Mainstream OS::
Windows, Linux, macOS

[[meal-entry]] Meal entry::
An entry representing a eaten meal.
Contains meal name, calories, and date/time consumed.

[[meal-db]] Meal database::

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
////

